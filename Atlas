#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           BtmLift1,      tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           LeftFront,     tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           LeftRear,      tmotorVex393HighSpeed_MC29, openLoop, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port4,           RightRear,     tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight, encoderPort, I2C_3)
#pragma config(Motor,  port5,           RightFront,    tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port6,           LeftLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           RightLift,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           LeftClaw,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           RightClaw,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          BtmLift2,      tmotorVex393_HBridge, openLoop, encoderPort, I2C_4)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"





// Set Value for words and phrases to use later
// Try not to change any values and if there are any specific ones add them using:// int [Name] = Value; //

int FULL = 127; 		// Please only use this for the lifts.
int HALF = 64;  		// Only necessary for testing speeds.
int TILE = 500;     //
int HALFTILE = 250; // Theoretically accurate.
int CONTROL = 15;		// Use this to maintain the lift.
int LEFT = (Ch3); 	// These two settings are
int RIGHT = (Ch2);	// for the controllers.
int SPEED = 100;  	// The Theoretically proper speed for the four wheels. IDK IDK IDK IDK maybe

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////// 	// If you changed or added anything other than Values (for example motor ports, adding int values, changing IMEs, etc.
// MAJOR CHANGES      // 	//
// ROBOT CODE LOGS    // 	//
// Please write down  // 	//
// what you changed.  // 	//                 // Then this would go here and please be sure to add it so nobody, Me(Efrain), gets confused
//////////////////////// 	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* 1/9/17 6:00am
Efrain: I changed the motors and sensors setup to have two lift motor controls instead of the usual four.
so the lifts are powered by four motors but are in only two ports to provide room for the back lift and reach
the 12 motor limit no problem.

1/9/17  6:35am
Efrain: I added autonomous voids for my other fellow programmers

1/9/17  7:00am
Efrain: Instead of having so much garbage in the user control I changed the motors into a void to keep it clean.

1/10/17 8:30am
Efrain: I have fixed the robot to not have to use so much for the "Deploy()". That was due to me changing the intake
to the claw and haveing a small fork to fit in constraints. I have also made a second deploy command for a back-up.

1/10/17 4:30pm
Efrain: I updated the Team auton sections so if you're a little rusty that's okay just write an auton you see fit. I'll
fix anything you might have errors in.

1/11/17 8:00am
Efrain: I added the claw functions into voids under the "User Fuctions"

1/12-13/17
Efrain: There was a major change in the bot but for the most part it was kept similar the build team added a more simpler
way to drop the lift of the fork. The claws were rebuilt to keep direction with the lift. There will need to be a high hang
issue without something hindering the lift.

1/16/17 8:20pm
Efrain: I spent a couple hours calculating the correct ticks for all the IEM values

*/
void pre_auton()
{
	bStopTasksBetweenModes = true; //This is necessary
}

//This section is for the Vex speaker module so only me(Efrain) and Jan can use it.
//Add Bool to use the right sounds an only once, also please don't use while loops if possible.
void beep()
{
	bPlaySounds = true;

	playSound(soundBeepBeep);

}
///////////////////
//---------------//
//  Autononmous  //
//  Functions    //
//---------------//
///////////////////


void Deploy1() //This will shake the bot to drop the fork.
//It would most likely be used all the time.
{
	startMotor(LeftRear,-SPEED);
	startMotor(RightRear,-SPEED);
	startMotor(LeftLift,FULL);
	startMotor(RightLift,FULL);
	wait(0.5);
	stopMotor(LeftRear);
	stopMotor(RightRear);
	stopMotor(LeftLift);
	stopMotor(RightLift);
}


void Deploy2 ()
/* This will just slightly shake the bot so the fork will fall to the floor, Theoretically it houldn't need
*/// too much to drop it

{
	startMotor(LeftRear,-SPEED);
	startMotor(RightRear,-SPEED);
	wait(0.3);
	stopMotor(LeftRear);
	stopMotor(RightRear);

}
void Deploy3()
{
	startMotor(RightLift,-SPEED);
	startMotor(LeftLift,-SPEED);
	startMotor(BtmLift1,-SPEED);
	startMotor(BtmLift2,-SPEED);
	wait(0.15);
	stopMotor(RightLift);
	stopMotor(LeftLift);
}


void LiftAll()// Activate the lift to full power... if you couldn't tell.
{
	startMotor(LeftLift,FULL);
	startMotor(RightLift,FULL);
	startMotor(BtmLift1,FULL);
	startMotor(BtmLift2,FULL);

}

void stopLift()// Stops the lift from lifting in any way... again if you couldn't already tell.
{
	stopMotor(LeftLift);
	stopMotor(RightLift);
	stopMotor(BtmLift1);
	stopMotor(BtmLift2);

}
void dropLiftFullSpeed()// Will drop the lift at full negative speed down.
{
	startMotor(LeftLift,-FULL);
	startMotor(RightLift,-FULL);
	startMotor(BtmLift1-FULL);
	startMotor(BtmLift2,-FULL);
}
void LiftUp()//
{
	startMotor(LeftLift,FULL);
	startMotor(RightLift,FULL);
}
void LiftDown()//
{
	startMotor(LeftLift,FULL);
	startMotor(RightLift,FULL);
}
	

//////////////////////
//------------------//
// IMEs Tick values //
//------------------//
//////////////////////
/*
DO NOT TOUCH THIS UNDER ANY CIRCUMSTANCE ONLY ME(EFRAIN).
I have spent hours correctly calculating the turn ticks 

500 ticks for one tile.
150 ticks for turning right on the Right Rear drive motor.
130 ticks for turning left on the Left Rear drive motor.

*/


void Driveforward() // The IMEs will take control and drive at the speed of 100 for 500 (ONE TILE) ticks
{
	wait1Msec(1);

	resetMotorEncoder(RightRear);
	resetMotorEncoder(LeftRear);
	resetMotorEncoder(LeftFront);
	resetMotorEncoder(RightFront);

	while(getMotorEncoder(LeftRear) < 500)
	{
		motor[RightRear] = 100;
		motor[LeftRear] = 100;
		motor[LeftFront] = 100;
		motor[RightFront] = 100;
	}

	motor[RightRear] = 0;
	motor[LeftRear] = 0;
	motor[LeftFront] = 0;
	motor[RightFront] = 0;
}
void Drivebackward()
{
	wait1Msec(1);

	resetMotorEncoder(RightRear);
	resetMotorEncoder(LeftRear);
	resetMotorEncoder(LeftFront);
	resetMotorEncoder(RightFront);

	while(getMotorEncoder(LeftRear) < -500)
	{
		motor[RightRear] = -100;
		motor[LeftRear] = -100;
		motor[LeftFront] = -100;
		motor[RightFront] = -100;
	}

	motor[RightRear] = 0;
	motor[LeftRear] = 0;
	motor[LeftFront] = 0;
	motor[RightFront] = 0;
}
void TurnLeft ()
{
	wait1Msec(1);

	//Turn Left
	resetMotorEncoder(RightRear);
	resetMotorEncoder(LeftRear);
	resetMotorEncoder(LeftFront);
	resetMotorEncoder(RightFront);

	while(getMotorEncoder(RightRear) < 150)
	{
		motor[RightRear] = 100;
		motor[LeftRear] = -100;
		motor[LeftFront] = -100;
		motor[RightFront] = 100;
	}

	motor[RightRear] = 0;
	motor[LeftRear] = 0;
	motor[LeftFront] = 0;
	motor[RightFront] = 0;
}
void TurnRight ()
{
	//Turn Right
	wait1Msec(1);

	resetMotorEncoder(RightRear);
	resetMotorEncoder(LeftRear);
	resetMotorEncoder(LeftFront);
	resetMotorEncoder(RightFront);

	while(getMotorEncoder(LeftRear) < 130)
	{
		motor[RightRear] = -100;
		motor[LeftRear] = 100;
		motor[LeftFront] = 100;
		motor[RightFront] = -100;
	}

	motor[RightRear] = 0;
	motor[LeftRear] = 0;
	motor[LeftFront] = 0;
	motor[RightFront] = 0;
}

void OpenClaw ()
{
	motor[LeftClaw] = FULL;
	motor[RightClaw] = FULL;
	wait(1);
	motor[LeftClaw] = 0;
	motor[RightClaw] = 0;
}

void HalfClaw ()
{
	motor[L

///////////////////////////
//UNOFFICIAL  AUTONOMOUS'//
//Write your autons here.//
///////////////////////////


/*----------------------------------------------------------------------------------------------------------------------------------------//
// TEAM AUTONS																																																														//
// Also I am very sorry I took control of all the programming this entire year but I really believe you all have untapped potential				//
// so please program as you see fit. I really want to include you guys on the team. Thank you for everything.															//
// P.S If you don't know how to use the voids I made then ignore them they are basically just folders in the programming you can always		//
// refer to.
//
//
//	Here is a sample auton you can always refer to if your a little lost. It's very basic. I just learned how to make it not basic.
//
//	//Begin Auton.
//    startMotor(RightWheel,110);
//    startMotor(LeftWheel,110);
//    //Lift will begin at the same time as the drive.
//    startMotor(RightUpLift,100);
//    startMotor(RightDownLift,100);
//    startMotor(LeftUpLift,100);
//    startMotor(LeftDownLift,100);
//    wait(1.6);//**
//    stopMotor(RightUpLift);
//    stopMotor(RightDownLift);
//    stopMotor(LeftDownLift);
//    stopMotor(LeftUpLift);
//
//    startMotor(RightUpLift,20);
//    startMotor(RightDownLift,20);
//    startMotor(LeftUpLift,20);
//    startMotor(LeftDownLift,20);
//    //The grabber will begin at the same time at a specific moment it will stop to fully extend out.
//    startMotor(Claw1,100);
//    startMotor(Claw2,100);
//    wait(0.5);
//    stopMotor(Claw1);
//    stopMotor(Claw2);
//
//    startMotor(Claw1,1);
//    startMotor(Claw2,1);
//    wait(0.5);
//    stopMotor(Claw1);
//    stopMotor(Claw2);
//    //The drive will stop to prepare for its next movement.
//    stopMotor(RightWheel);
//    stopMotor(LeftWheel);
//    //The drive will begin to retreat back for a **quarter of a second.
//    startMotor(RightWheel,-127);
//    startMotor(LeftWheel,-127);
//    wait(0.25);//**
//    stopMotor(RightWheel);
//    stopMotor(LeftWheel);
//    //The Lift will come down to prepare for the next movement.
//    stopMotor(RightUpLift);
//    stopMotor(RightDownLift);
//    stopMotor(LeftUpLift);
//    stopMotor(LeftDownLift);
//    //The drive will turn to the right preparing to grab onto the cube
//    startMotor(RightWheel,127);
//    startMotor(LeftWheel,-127);
//    wait(0.75);
//    stopMotor(RightWheel);
//    stopMotor(LeftWheel);
//
//    startMotor(RightWheel,127);
//    startMotor(LeftWheel,127);
//    wait(1);
//    stopMotor(RightWheel);
//    stopMotor(LeftWheel);
//
//		********************************************************
//		**THIS AUTON IS INCREDIBLY OUTDATED IT WAS FOR SKYRISE**
//		********************************************************
//----------------------------------------------------------------------------------------------------------------------------------------*/



void DonR() //1st auton. UNTESTED// by non-other than Efrain

{


	Drivebackward();
	wait(1);
	Drivebackward();
	wait(1);
	LiftAll();
	wait(1.6);
	Driveforward();
	wait(1);
	TurnLeft();
	wait(1);
	Driveforward();
	wait(1);


}


// POINTS SCORED:
//
void Dave()
{	//Write auton here
	// startMotor(RightRear, );
	// startMotor(LeftRear, );
	// wait(1); // In Seconds (Move the bot forward)
	// stopMotor(RightRear);
	// startMotor(RightFront, - );
	// wait(1); // Turns the bot to face the cube (Right)
	// stopMotor(RightFront);
	// startMotor(RightRear, );
	// wait(1); // Moves the bot forward and the cube in front of it
	// stopMotor(LeftRear);
	// stopMotor(RightRear);
	// startMotor(Claw1, );
	// startMotor(Claw2, );
	// wait(1); // Grabs the cube
	// stopMotor(Claw1);
	// stopMotor(Claw2);
	// startMotor(LeftLifts, );
	// startMotor(RightLifts, ); // THE HEIGHT OF THE LIFT MUST NOT BE TOO HIGH B/C IF IT IS TOO HIGH IT WILL NOT HIT STARS
	// wait(1); Lifts the cube up
	// stopMotor(LeftLifts);
	// stopMotor(RightLifts);
	// startMotor(RightFront, );
	// startMotor(LeftRear, - );
	// wait(1); //Turns the bot left (facing the fence)
	// stopMotor(RightFront );
	// startMotor(LeftRear, );
	// startMotor(RightRear, );
	// wait(1); //Rams the fence
	// startMotor(Claw1, - );
	// startMotor(Claw2, - );
	// wait(1); // Drops the cube and hopefully hit stars in the process of moving forward
	// startMotor(LeftLifts, );
	// startMotor(RightLifts, ); // FULL HEIGHT
	// startMotor(LeftRear, - );
	// startMotor(RightFront,); 
	// wait(1); // Turns left hopefully hitting the Up high stars on the left side of the field
	// stopMotor(RightFront);
	// startMotor(LeftRear, );
	// startMotor(RightRear, );
	// wait(3); // 
	// stopMotor(LeftLifts);
	// stopMotor(RightLifts);
	// stopMotor(LeftRear);
	// stopMotor(RightRear);
	// I NEED TO TEST OUT NUMBERS OF THE MOTORS AND HOW LONG THE WAIT TIMES ARE BUT I HAVE CREATED A VERY GOOD SKELETON OF AN AUTONOMOUS
}



// POINTS SCORED:
//
/*
void Daniel()
{	//start auton
	//Use the deploy thing first so that the lift drops down to the ground to start.
	startMotor(RightFront,100);
	startMotor(LeftRear,-100);
	wait(1); // In Seconds
	stopMotor(RightFront);
	stopMotor(LeftRear);
	//turn left
	startMotor(Claw1,100);
	startMotor(Claw2,100);
	wait(1); // In Seconds
	stopMotor(Claw1);
	stopMotor(Claw2);
	//pick up star to the left of starting square
	startMotor(RightRear,-100);
	startMotor(LeftFront,100);
	wait(1); // In Seconds
	stopMotor(RightRear);
	stopMotor(LeftFront);
	//turn back to front-face
	startMotor(RightFront,127);
	startMotor(RightRear,127);
	startMotor(LeftFront,127);
	startMotor(LeftRear,127);
	wait(4); // In Seconds
	stopMotor(RightFront);
	stopMotor(RightRear);
	stopMotor(LeftFront);
	stopMotor(LeftRear);
	//drive up to fence
	startMotor(LeftLifts,100);
	startMotor(RightLifts,100);
	wait(1); // In Seconds
	stopMotor(LeftLifts);
	stopMotor(RightLifts);
	//lift lifts all the way up
	startMotor(RightFront,127);
	startMotor(RightRear,127);
	startMotor(LeftFront,127);
	startMotor(LeftRear,127);
	wait(0.25); // In Seconds
	stopMotor(RightFront);
	stopMotor(RightRear);
	stopMotor(LeftFront);
	stopMotor(LeftRear);
	//drive directly into fence to push stars off of fence
	startMotor(LeftLifts,-100);
	startMotor(RightLifts,-100);
	wait(0.25); // In Seconds
	stopMotor(LeftLifts);
	stopMotor(RightLifts);
	//drop lift onto fence (make it flat) so that when claws open the stars fall off onto the other side
	startMotor(Claw1,-127);
	startMotor(Claw2,-127);
	wait(1); // In Seconds
	stopMotor(Claw1);
	stopMotor(Claw2);
	//open claw to drop contents
	startMotor(RightFront,-127);
	startMotor(RightRear,-127);
	startMotor(LeftFront,-127);
	startMotor(LeftRear,-127);
	wait(0.5); // In Seconds
	stopMotor(RightFront);
	stopMotor(RightRear);
	stopMotor(LeftFront);
	stopMotor(LeftRear);
	//back away from fence
	startMotor(LeftLifts,-127);
	startMotor(RightLifts,-127);
	wait(1); // In Seconds
	stopMotor(LeftLifts);
	stopMotor(RightLifts);
	//drop the platform onto the ground
	startMotor(RightRear,-127);
	startMotor(LeftFront,127);
	wait(1); // In Seconds
	stopMotor(RightRear);
	stopMotor(LeftFront);
	//turn right to face the cube directly
	startMotor(RightFront,127);
	startMotor(RightRear,127);
	startMotor(LeftFront,127);
	startMotor(LeftRear,127);
	wait(1); // In Seconds
	stopMotor(RightFront);
	stopMotor(RightRear);
	stopMotor(LeftFront);
	stopMotor(LeftRear);
	//drive into cube so that the platform is positioned under cube
	startMotor(Claw1,127);
	startMotor(Claw2,127);
	wait(1); // In Seconds
	stopMotor(Claw1);
	stopMotor(Claw2);
	//close claw around cube
	startMotor(RightFront,100);
	startMotor(LeftRear,-100);
	wait(1); // In Seconds
	stopMotor(RightFront);
	stopMotor(LeftRear);
	//turn left in order to face towards fence
	startMotor(LeftLifts,100);
	startMotor(RightLifts,100);
	wait(1); // In Seconds
	stopMotor(LeftLifts);
	stopMotor(RightLifts);
	//lift lifts all the way up
	startMotor(RightFront,127);
	startMotor(RightRear,127);
	startMotor(LeftFront,127);
	startMotor(LeftRear,127);
	wait(0.25); // In Seconds
	stopMotor(RightFront);
	stopMotor(RightRear);
	stopMotor(LeftFront);
	stopMotor(LeftRear);
	//drive directly into fence to push stars off of fence
	startMotor(LeftLifts,-100);
	startMotor(RightLifts,-100);
	wait(0.25); // In Seconds
	stopMotor(LeftLifts);
	stopMotor(RightLifts);
	//drop lift onto fence (make it flat) so that when claws open the cube falls off onto the other side
	startMotor(Claw1,-127);
	startMotor(Claw2,-127);
	wait(1); // In Seconds
	stopMotor(Claw1);
	stopMotor(Claw2);
	//open claw to drop the cube onto the other side

	//this will probably barely make time limit if even


}

//POINTS SCORED: 5 (weak sauce. I'm sorry! But, it does set up for a good driver control start) Possibly scores 11 max but the
//auton might be super overloaded based on the time limit so in theory it can get 11 if other robots dont interfere or
//score any of the points I plan on scoring with this auton obviously. I do not know the grammar really anymore so you will
//have to add in necessary brackets (I think the only things I left out). Also, I will need to test it in person tomorrow
//to fine tune wait times and motor values and such. In theory this is the frame though.


void Ocean_Man()// I dunno man just don't use it, its a secret weapon i swear
{

}




///////////////////
//---------------//
// User Function //
//---------------//
///////////////////

void LiftUp ()
{
	motor[LeftLifts] = FULL;
	motor[RightLifts] = FULL;
	motor[ExtraLift1] = FULL;
	motor[ExtraLift2] = FULL;

}

void LiftDown ()
{
	motor[LeftLifts] = -FULL;
	motor[RightLifts] = -FULL;
	motor[ExtraLift1] = -FULL;
	motor[ExtraLift2] = -FULL;

}
void ClawOpen ()
{
	motor[Claw1] = FULL;
	motor[Claw2] = FULL;
}
void ClawClose ()
{
	motor[Claw1] = -FULL;
	motor[Claw2] = -FULL;
}
*?
/*************************************/
///////////////////////////////////////
//----------HYBRID FUNCTIONS---------//
// These void values will go in both //
// auton and the driver control. pls //
// don't get too crazy.              //
///////////////////////////////////////
/*************************************/
void HighHang ()// THE BICEP CURL
{
	if(vexRT[Btn8U] ==1)
	{
		LiftAll();
		wait(1.5);
		stopLift();
		dropLiftFullSpeed();
	}
}
/*------------------------------------------------------------------------------------------------/
///////////////////////////////////////////////////////////////////////////////////////////////////
Alright time for the real time, this is most important part of this robot if you, Dave or Daniel,
decide to put anything in the skills section make sure you use the whole 1 minute of it.
And be sure to reference your voids that were in the auton sections and to do that is easy
Just type your name then follow up with a "();" and it should be ready for your program.
GOOD LUCK.
//////////////////////////////////////////////////////////////////////////////////////////////////
------------------------------------------------------------------------------------------------*/
void skills()// Please make this as accurate as possible and don't touch it if you aren't Efrain.
{


}


task autonomous()// Efrain is open to suggestions it really helps me please.
{


	DonR();

	AutonomousCodePlaceholderForTesting();
}


//This is where we begin driver control
task usercontrol()
{


	while (true)
	{

		{
			motor[LeftRear] = vexRT(LEFT);
			motor[LeftFront] = vexRT(LEFT);
			motor[RightRear] = vexRT(RIGHT);
			motor[RightFront] = vexRT(RIGHT);
		}
		if(vexRT[Btn6U] ==1)
		{
			LiftUp();
		}
		else if(vexRT[Btn6D] ==1)
		{
			LiftDown();
		}
		else
		{
			motor[LeftLift] = 10;
			motor[RightLift] = 10;
		}

		if(vexRT[Btn5U] ==1)
		{
			ClawOpen ();
		}

		else if(vexRT[Btn5D] ==1)
		{
			ClawClose ();
		}

		else
		{
			motor[LeftClaw] = 2;
			motor[RightClaw] = 2;
		}






	}

}
